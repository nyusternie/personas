// SPDX-License-Identifier: MIT
pragma cashscript ^0.9.0;

/**
 * @title Hotel
 * @notice Contract factory for deploying and managing Concierge permission systems
 * @author 0xShomari
 * @dev Factory pattern for creating configured wallet management contracts
 *
 * Features:
 * - Template-based contract deployment
 * - Pre-configured permission presets
 * - Deployment fee system
 * - Version management and upgrades
 * - Deployment registry and tracking
 * - Multi-admin factory governance
 *
 * @custom:version 25.11.23
 * @custom:security-contact security@0xshomari.com
 *
 * Copyright (c) 2025 0xShomari. All rights reserved.
 */

contract Hotel {
    // Factory owner
    pub key factoryOwner;

    // Template contracts and deployment fees
    int deploymentFee;
    int templateVersion;

    // Deployment registry
    struct Deployment {
        bytes32 contractAddress;
        pub key owner;
        int deploymentTime;
        bytes32 configHash;
        bool active;
    }

    Deployment[] deployments;

    // Available templates
    bytes32[] templateHashes;
    bytes[] templateScripts;

    // Configuration presets
    struct Preset {
        string name;
        int dailyLimit;
        int weeklyLimit;
        int monthlyLimit;
        int adminConsensus;
    }

    Preset[] presets;

    // Statistics
    int totalDeployments;
    int activeDeployments;
    int totalFeesCollected;

    // Admin keys for factory management
    pub key[] factoryAdmins;
    int requiredFactoryConsensus;

    // Constructor
    constructor(
        pub key _owner,
        int _deploymentFee,
        pub key[] _admins,
        int _requiredConsensus
    ) {
        factoryOwner = _owner;
        deploymentFee = _deploymentFee;
        factoryAdmins = _admins;
        requiredFactoryConsensus = _requiredConsensus;
        templateVersion = 1;

        initializePresets();
        initializeTemplates();
    }

    // Bulk deployment with optimized loops
    function deployMultipleContracts(
        int[] presetIds,
        pub key[] owners,
        pub key[][] adminsList,
        int templateId
    ) returns (bytes32[] memory) {
        require(presetIds.length == owners.length);
        require(presetIds.length == adminsList.length);

        bytes32[] memory contractAddresses = new bytes32[](presetIds.length);
        int i = 0;

        do {
            contractAddresses[i] = deployConcierge(
                presetIds[i],
                owners[i],
                adminsList[i],
                new bytes(0),
                templateId
            );
            i = i + 1;
        } while (i < presetIds.length);

        return contractAddresses;
    }

    // Get deployment statistics with optimized counting
    function getDeploymentStats() returns (
        int total,
        int active,
        int inactive,
        int recentDeployments
    ) {
        total = totalDeployments;
        active = activeDeployments;
        inactive = totalDeployments - activeDeployments;

        // Count recent deployments (last 30 days)
        int recentCount = 0;
        int thirtyDaysAgo = tx.time - 2592000;
        int i = 0;

        do {
            if (deployments[i].deploymentTime >= thirtyDaysAgo) {
                recentCount = recentCount + 1;
            }
            i = i + 1;
        } while (i < deployments.length);

        return (total, active, inactive, recentCount);
    }

    // Deploy a new Concierge contract
    function deployConcierge(
        int presetId,
        pub key owner,
        pub key[] admins,
        bytes customConfig,
        int templateId
    ) returns (bytes32) {
        require(templateId >= 0 && templateId < templateScripts.length);
        require(presetId >= -1 && presetId < presets.length);

        // Collect deployment fee
        require(collectDeploymentFee());

        // Get configuration
        Preset memory config;
        if (presetId >= 0) {
            config = presets[presetId];
        } else {
            config = parseCustomConfig(customConfig);
        }

        // Deploy contract
        bytes32 contractAddress = deployContract(templateScripts[templateId], owner, admins, config);

        // Record deployment
        deployments.push(Deployment({
            contractAddress: contractAddress,
            owner: owner,
            deploymentTime: tx.time,
            configHash: sha256(customConfig),
            active: true
        }));

        totalDeployments += 1;
        activeDeployments += 1;

        return contractAddress;
    }

    // Bulk template management
    function updateTemplates(
        sig[] adminSigs,
        bytes[] newTemplates
    ) {
        require(verifyFactoryConsensus(adminSigs));

        // Clear existing templates
        templateScripts.length = 0;
        templateHashes.length = 0;

        // Add new templates using loop
        int i = 0;
        do {
            templateScripts.push(newTemplates[i]);
            templateHashes.push(sha256(newTemplates[i]));
            i = i + 1;
        } while (i < newTemplates.length);

        templateVersion += 1;
    }

    // Mass deactivation of deployments
    function deactivateMultipleDeployments(
        sig[] adminSigs,
        int[] deploymentIds
    ) {
        require(verifyFactoryConsensus(adminSigs));

        int deactivatedCount = 0;
        int i = 0;

        do {
            int depId = deploymentIds[i];
            if (depId >= 0 && depId < deployments.length && deployments[depId].active) {
                deployments[depId].active = false;
                deactivatedCount = deactivatedCount + 1;
            }
            i = i + 1;
        } while (i < deploymentIds.length);

        activeDeployments = activeDeployments - deactivatedCount;
    }

    // Find deployments by owner with optimized search
    function findDeploymentsByOwner(pub key ownerAddr) returns (int[] memory) {
        int[] memory ownerDeployments = new int[](deployments.length);
        int count = 0;
        int i = 0;

        do {
            if (deployments[i].owner == ownerAddr && deployments[i].active) {
                ownerDeployments[count] = i;
                count = count + 1;
            }
            i = i + 1;
        } while (i < deployments.length);

        // Trim the array to actual size
        int[] memory result = new int[](count);
        int j = 0;
        do {
            result[j] = ownerDeployments[j];
            j = j + 1;
        } while (j < count);

        return result;
    }

    // Internal functions
    function collectDeploymentFee() internal returns (bool) {
        if (deploymentFee > 0) {
            // Fee collection logic would go here
            totalFeesCollected += deploymentFee;
            return true;
        }
        return true;
    }

    function verifyFactoryConsensus(sig[] adminSigs) internal returns (bool) {
        require(adminSigs.length == factoryAdmins.length);

        int validSigs = 0;
        int i = 0;

        do {
            if (checkSig(adminSigs[i], factoryAdmins[i])) {
                validSigs = validSigs + 1;
            }
            i = i + 1;
        } while (i < factoryAdmins.length);

        return validSigs >= requiredFactoryConsensus;
    }

    function initializePresets() internal {
        // Personal Wallet Preset
        presets.push(Preset({
            name: "personal",
            dailyLimit: 50000000,
            weeklyLimit: 250000000,
            monthlyLimit: 1000000000,
            adminConsensus: 1
        }));

        // Business Wallet Preset
        presets.push(Preset({
            name: "business",
            dailyLimit: 500000000,
            weeklyLimit: 2500000000,
            monthlyLimit: 10000000000,
            adminConsensus: 2
        }));

        // Institutional Preset
        presets.push(Preset({
            name: "institutional",
            dailyLimit: 5000000000,
            weeklyLimit: 25000000000,
            monthlyLimit: 100000000000,
            adminConsensus: 3
        }));
    }

    function initializeTemplates() internal {
        templateScripts.push(compileBasicConcierge());
        templateHashes.push(sha256(templateScripts[templateScripts.length - 1]));

        templateScripts.push(compileAdvancedConcierge());
        templateHashes.push(sha256(templateScripts[templateScripts.length - 1]));
    }

    function parseCustomConfig(bytes config) internal returns (Preset memory) {
        return Preset({
            name: "custom",
            dailyLimit: 100000000,
            weeklyLimit: 500000000,
            monthlyLimit: 2000000000,
            adminConsensus: 1
        });
    }

    function deployContract(
        bytes template,
        pub key owner,
        pub key[] admins,
        Preset config
    ) internal returns (bytes32) {
        bytes memory deploymentData = template + owner + admins;
        return sha256(deploymentData);
    }

    function compileBasicConcierge() internal returns (bytes memory) {
        return new bytes('BASIC_CONCIERGE_TEMPLATE');
    }

    function compileAdvancedConcierge() internal returns (bytes memory) {
        return new bytes('ADVANCED_CONCIERGE_TEMPLATE');
    }
}
