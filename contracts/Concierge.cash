// SPDX-License-Identifier: MIT
pragma cashscript ^0.9.0;

/**
 * @title Concierge
 * @notice Comprehensive wallet permission management system
 * @author 0xShomari
 * @dev Manages spending limits, action permissions, and administrative controls
 *
 * Features:
 * - Time-based spending limits (daily, weekly, monthly)
 * - Action-specific permissions (staking, DeFi, NFTs, etc.)
 * - Multi-tier administrative controls
 * - Emergency freeze capabilities
 * - Configurable permission sets
 * - Integration with BCH CHIPs for optimized operations
 *
 * @custom:version 25.11.23
 * @custom:security-contact security@0xshomari.com
 *
 * Copyright (c) 2025 0xShomari. All rights reserved.
 */

contract Concierge {
    // Wallet owner
    pub key owner;

    // Permission structure
    struct Permission {
        int actionType;
        int limitAmount;
        int periodType;
        int lastUsed;
        int usedThisPeriod;
        bool enabled;
    }

    // Mapping of permission IDs to Permission structs
    Permission[] permissions;

    // Action type constants
    int constant ACTION_STAKING = 1;
    int constant ACTION_PAYOUT = 2;
    int constant ACTION_VAULT = 3;
    int constant ACTION_TRANSFER = 4;
    int constant ACTION_SWAP = 5;
    int constant ACTION_BORROW = 6;
    int constant ACTION_LIQUIDITY = 7;
    int constant ACTION_NFT_MINT = 8;
    int constant ACTION_NFT_TRANSFER = 9;
    int constant ACTION_GOVERNANCE = 10;
    int constant ACTION_CONTRACT_INTERACTION = 11;

    // Period type constants
    int constant PERIOD_DAILY = 1;
    int constant PERIOD_WEEKLY = 2;
    int constant PERIOD_MONTHLY = 3;
    int constant PERIOD_ONCE = 4;

    // Global limits
    int globalDailyLimit;
    int globalWeeklyLimit;
    int globalMonthlyLimit;
    int globalDailyUsed;
    int globalWeeklyUsed;
    int globalMonthlyUsed;
    int lastGlobalReset;

    // Multi-sig requirements for sensitive actions
    pub key[] administrators;
    int requiredAdminConsensus;

    // Check if an action is permitted with optimized period checking
    function checkPermission(int permissionId, int amount) returns (bool) {
        require(permissionId >= 0 && permissionId < permissions.length);

        Permission memory perm = permissions[permissionId];
        require(perm.enabled);

        // Reset periods if needed
        resetPeriods();

        // Check global limits
        require(globalDailyUsed + amount <= globalDailyLimit);
        require(globalWeeklyUsed + amount <= globalWeeklyLimit);
        require(globalMonthlyUsed + amount <= globalMonthlyLimit);

        // Check permission-specific limits
        int periodReset = shouldResetPeriod(perm.periodType, perm.lastUsed);
        int currentUsed = periodReset == 1 ? 0 : perm.usedThisPeriod;

        require(currentUsed + amount <= perm.limitAmount);

        // Update usage
        globalDailyUsed += amount;
        globalWeeklyUsed += amount;
        globalMonthlyUsed += amount;
        permissions[permissionId].usedThisPeriod = currentUsed + amount;
        permissions[permissionId].lastUsed = tx.time;

        return true;
    }

    // Reset period counters using optimized time checking
    function resetPeriods() internal {
        int currentTime = tx.time;

        bool dailyReset = (currentTime - lastGlobalReset) >= 86400;
        bool weeklyReset = (currentTime - lastGlobalReset) >= 604800;
        bool monthlyReset = (currentTime - lastGlobalReset) >= 2592000;

        if (monthlyReset) {
            globalMonthlyUsed = 0;
            globalWeeklyUsed = 0;
            globalDailyUsed = 0;
            lastGlobalReset = currentTime;
        } else if (weeklyReset) {
            globalWeeklyUsed = 0;
            globalDailyUsed = 0;
            lastGlobalReset = currentTime;
        } else if (dailyReset) {
            globalDailyUsed = 0;
            lastGlobalReset = currentTime;
        }
    }

    // Check if period should reset
    function shouldResetPeriod(int periodType, int lastUsed) internal returns (int) {
        int currentTime = tx.time;

        if (periodType == PERIOD_DAILY) {
            return (currentTime - lastUsed) >= 86400 ? 1 : 0;
        } else if (periodType == PERIOD_WEEKLY) {
            return (currentTime - lastUsed) >= 604800 ? 1 : 0;
        } else if (periodType == PERIOD_MONTHLY) {
            return (currentTime - lastUsed) >= 2592000 ? 1 : 0;
        } else if (periodType == PERIOD_ONCE) {
            return lastUsed == 0 ? 1 : 0;
        }

        return 0;
    }

    // Optimized admin consensus verification
    function verifyAdminConsensus(sig[] adminSigs) internal returns (bool) {
        require(adminSigs.length == administrators.length);

        int validSigs = 0;
        int i = 0;

        do {
            if (checkSig(adminSigs[i], administrators[i])) {
                validSigs = validSigs + 1;
            }
            i = i + 1;
        } while (i < administrators.length);

        return validSigs >= requiredAdminConsensus;
    }

    // Add multiple permissions using loop
    function addPermissions(
        sig ownerSig,
        Permission[] newPermissions
    ) {
        require(checkSig(ownerSig, owner));

        int i = 0;
        do {
            permissions.push(newPermissions[i]);
            i = i + 1;
        } while (i < newPermissions.length);
    }

    // Bulk permission modification
    function modifyPermissions(
        sig ownerSig,
        int[] permissionIds,
        int[] newLimits,
        bool[] newEnabled
    ) {
        require(checkSig(ownerSig, owner));
        require(permissionIds.length == newLimits.length);
        require(permissionIds.length == newEnabled.length);

        int i = 0;
        do {
            int permId = permissionIds[i];
            if (permId >= 0 && permId < permissions.length) {
                permissions[permId].limitAmount = newLimits[i];
                permissions[permId].enabled = newEnabled[i];
            }
            i = i + 1;
        } while (i < permissionIds.length);
    }

    // Get total usage across all permissions
    function getTotalUsage() returns (int daily, int weekly, int monthly) {
        int totalDaily = globalDailyUsed;
        int totalWeekly = globalWeeklyUsed;
        int totalMonthly = globalMonthlyUsed;

        // Sum up permission-specific usage
        int i = 0;
        do {
            Permission memory perm = permissions[i];
            if (perm.enabled) {
                int reset = shouldResetPeriod(perm.periodType, perm.lastUsed);
                if (reset == 0) { // Only count if period hasn't reset
                    totalDaily += perm.usedThisPeriod;
                    totalWeekly += perm.usedThisPeriod;
                    totalMonthly += perm.usedThisPeriod;
                }
            }
            i = i + 1;
        } while (i < permissions.length);

        return (totalDaily, totalWeekly, totalMonthly);
    }

    // Get all permissions for a specific action type
    function getPermissionsByType(int actionType) returns (Permission[] memory) {
        Permission[] memory result = new Permission[](permissions.length);
        int count = 0;
        int i = 0;

        do {
            if (permissions[i].actionType == actionType && permissions[i].enabled) {
                result[count] = permissions[i];
                count = count + 1;
            }
            i = i + 1;
        } while (i < permissions.length);

        // Trim array to actual size
        Permission[] memory trimmedResult = new Permission[](count);
        int j = 0;
        do {
            trimmedResult[j] = result[j];
            j = j + 1;
        } while (j < count);

        return trimmedResult;
    }

    // Initialize with default permissions
    constructor(
        pub key _owner,
        int _globalDailyLimit,
        int _globalWeeklyLimit,
        int _globalMonthlyLimit,
        pub key[] _admins,
        int _requiredAdminConsensus
    ) {
        owner = _owner;
        globalDailyLimit = _globalDailyLimit;
        globalWeeklyLimit = _globalWeeklyLimit;
        globalMonthlyLimit = _globalMonthlyLimit;
        administrators = _admins;
        requiredAdminConsensus = _requiredAdminConsensus;
        lastGlobalReset = tx.time;

        // Add default permissions
        setupDefaultPermissions();
    }

    function setupDefaultPermissions() internal {
        // Add some default permissions
        addDefaultPermission(ACTION_TRANSFER, 100000000, PERIOD_DAILY, true); // 1 BCH daily
        addDefaultPermission(ACTION_STAKING, 50000000, PERIOD_DAILY, true); // 0.5 BCH daily
        addDefaultPermission(ACTION_SWAP, 200000000, PERIOD_WEEKLY, true); // 2 BCH weekly
    }

    function addDefaultPermission(int actionType, int limit, int period, bool enabled) internal {
        permissions.push(Permission({
            actionType: actionType,
            limitAmount: limit,
            periodType: period,
            lastUsed: 0,
            usedThisPeriod: 0,
            enabled: enabled
        }));
    }
}
